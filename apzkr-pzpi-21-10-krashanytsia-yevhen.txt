Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук


Кафедра програмної інженерії


КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для навчання грі на гітарі за допомогою розумних пристроїв


		Студент гр. ПЗПІ-21-10		_________________ Крашаниця Є.С.
							(підпис)
		Керівник роботи			_________________ доц. Лещинська І.О.
							(підпис)
							      Роботу захищено «__» ______ 2024.р
							      з оцінкою _______________________
		Комісія:				_______________ доц. Лещинський В.О.
								(підпис)
							_______________ доц. Лещинська І.О.
								(підпис)
							_______________ ст. викл. Сокорчук І.П.
								(підпис)
Харків
2024 р.
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук	 	 Кафедра програмної інженерії		
Спеціальність 121 – Інженерія програмного забезпечення					
Курс  	3	 Семестр						6				
Навчальна дисципліна Архітектура програмного забезпечення				

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

				Крашаниці Євгену Сергійовичу				
1. Тема роботи: «Програмна система для навчання грі на гітарі за допомогою розумних пристроїв»										
2. Термін узгодження завдання курсової роботи «04»	 	березня	 2024 р.
3. Термін здачі студентом закінченої роботи «15»	червня	 2024 р.
4. Вихідні дані до проекту (роботи): У програмній системі передбачити: регулювання вихідного звуку інструменту, навчання гравців, оптимізація часу користувачів. Використовувати ОС Windows 10 або 11, СКБД PostgreSQL, середовище розробки WebStorm							
5. Зміст пояснювальної записки (перелік питань, що належить розробити) вступ, аналіз предметної області, постановка задачі, проектування програмного проєкту, структуру бази даних, кодування програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки					
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень)
UML діаграма розгортання, UML – діаграма взаємодії, UML діаграма діяльності, UML діаграма прецедентів, UML діаграма станів, інтерфейс веб – застосунку, UML діаграма компонентів, UML діаграма пакетів, інтерфейс мобільного застосунку, будова IoT пристрою, ER-модель даних,				


КАРЛЕНДАРНИЙ ПЛАН


№
Назва етапів курсової роботи
Термін виконання
етапів роботи
Примітка
1
Функціональна специфікація
програмного проекту
05.03.2024
Виконано
2
Проектування програмного
проекту
21.03.2024
Виконано
3
Кодування програмного проекту
21.04.2024
Виконано
4
Оформлення пояснювальної записки
22.05.2024
Виконано
5
Захист курсової роботи
15.05.2024
Виконано

     Дата видачі завдання «	  4   » 		березня	 2024 р.

		Керівник 					          	          доц. Лещинська І.О.
								(підпис)
		
      Завдання прийняв до виконання
     ст. гр. ПЗПІ-21-10					      Крашаниця Є.С.
     					     (підпис)
      
      
      
      
      
      
      
      
     РЕФЕРАТ
     
     
     Пояснювальна записка до курсової роботи:  41 сторінок,  37 рисунків, 5 джерел.
     ГІТАРИ, ЕКВАЛАЙЗЕР, МУЗИКА, МОВА ПРОГРАМУВАННЯ JAVA SCRIPT, АРХІТЕКТУРА, НАВЧАННЯ, ДИСТАНЦІЙНЕ КЕРУВАННЯ, ЦІНА,  АНДРОІД, KOTLIN, ПРОГРАМНА СИСТЕМА.
     Об’єктом досліджень є музична індустрія розважання, а саме зручне користування електронними гітарами без додаткових приладів, та навчання грі на ній за допомогою сучасних технологій.
     Курсовий проект створений з метою полегшення навчання грі на гітарі, та зменшення витрат на додаткових пристроях. Він покращить рівень гри музикантів, за допомогою навчальної системи з різними жанрами. Зменшить витрати на додаткове приладдя як комбопосилювач, педалі, аудіо шнури, бо все буде вбудовано у саму гітару. Покращить якість звучання за допомогою детального еквалайзеру з різними музикальними стилями. Збільшить автономність гравця, через необхідності у гітарі та телефоні для грі. Також простий та зрозумілий сайт дозволить просто та швидко обрати та купити саме ту гітару, яка буде необхідна користувачу.
     Методи розробки базуються на використанні серед розробки WebStorm, Android Studio та емуляторі Wokwi. Веб додаток створений за допомогою React, Node JS та Express. Для реалізації мобільного застосунку я використовував мову програмування Kotlin, для IOT пристрою було використана плата ESP32, потенціометр, звуковий динамік, вбудований bluetooth модуль та мову програмування C++.
     В результаті отримана програмна система, яка дозволяє переглядати гітари, купляти їх, дистанційно або фізично керувати аудіо системою у самій гітарі за допомогою мобільного додатку або фізичних приладів.
ЗМІСТ

Вступ	6
1 Специфікація програми	7
1.1	Основні функції програми	7
1.2	Опис функцій веб-додатку для користувача	10
1.2.1 Авторизація та реєстрація	10
1.2.2 Перегляд гітар	12
1.2.3 Кошик та оформлення замовлення	13
1.3	Опис функцій IOT пристрою для користувача	15
1.3.1 Функція регулювання гучності	15
1.3.2 Вибір режиму звуку	15
1.4	Функції мобільного застосунку для користувача.	16
1.4.1	Реєстрація та авторизація	16
1.4.2	Функція еквалайзеру	18
1.4.3	Режим навчання	20
1.4.4	Функція підключення до IOT пристрою	21
2	Проектування програми	22
2.1	Архітектура серверної частини	22
2.2	Архітектура клієнтської частини	26
2.3	Архітектура мобільного додатку	31
2.4	Архітектура IOT пристрою	33
Висновки	34
Перелік посилань	35
Додаток А	36
Додаток Б	37
Додаток В	39




ВСТУП


   Метою моєї курсової роботи є створення програмної системи для навчання грі на гітарі за допомогою розумних пристроїв. Для виконання цієї задачі були реалізовані наступні функції:
– Обрання на покупку гітари;
– Перегляд детальної інформації про гітари;
– Додавання нових гітар(для адміністратора);
– Додавання нових категорій (для адміністратора);
– Підключення дистанційного пристрою до мобільного додатку
– Налаштування звуку пристрою;
– Режим навчання;
– Фізичне керування пристроєм.
   Програма бура розроблена на мовах програмування JS, Kotlin [2,3]на платформах WebStorm та Android Studio, за допомогою React, Node JS[4], Express.
   Програмна система використовується для перегляду та покупки гітар, та для керування дистанційним приладом за допомогою мобільного додатку.













   1 СПЕЦИФІКАЦІЯ ПРОГРАМИ
1.1 Основні функції програми

     Завдяки програмній системі можна переглядати загальний список гітар, додавати гітари та за бажанням переглядати детальну інформацію про гітару, та купляти їх. Також є можливість підключення андроід пристрою до IOT девайсу, та керування ним як дистанційно так і фізично. 
Щоб здійснити це, моя система має в собі наступні функції:
Для користувача:
– Реєстрація;
– Авторизація;
– Перегляд гітар;
– Переглядання детальної інформації про монети;
– Додавання гітар до кошику;
– Перегляд Наповнення кошику;
– Оформлення замовлення;
– Перегляд інформації про сторінку за допомогою f1.
– Для адміністратору:
– Вхід у програму;
– Перегляд гітар;
– Додавання нових гітар;
– Додавання нових категорій;
– Переглядання детальної інформації про монети;
– Додавання гітар до кошику;
– Перегляд Наповнення кошику;
– Оформлення замовлення;
– Перегляд інформації про сторінку за допомогою f1.


   Алгоритм роботи з цих функцій ми бачимо на Use Case діаграмах, які відображають прецеденти для сайту (див. рис. 1.1), IOT  (див. рис. 1.2) та мобільного застосунку(див. рис. 1.3).
   

   Рисунок 1.1 – Діаграма прецедентів для веб застосунку
   
   Як ми бачимо у системі може існувати 3 види користувачів:
- Незареєстрований користувач, який може тільки продивлятись товари та зареєструватись;
- Зареєстрований користувач, він може так само переглядати товари, але на відмін від незареєстрованих також може додавати їх до кошика, та оформлювати замовлення;
- Адміністратор це люде яка може адмініструвати сайт, він має можливість додавати товари та категорії, може видаляти їх, та керувати за користувачами та видаляти їх за необхідністю. 
   
   
   Рисунок 1.2 – Діаграма прецедентів для IOT пристрою
   
   Як ми бачимо у системі може існувати 2 види користувачів:
- Користувачі які мають електронний додаток, та можуть регулювати гучність, переключати музичні стилі та створювати свої та також вмикати режим навчання гри на гітарі;
- Користувач без додатку, який обмежений лише фізичними складовими девайсу, а саме регулювання гучності, та перемикання базових режимів.

   
   
   Рисунок 1.3 – Діаграма прецедентів для мобільного застосунку
   
Як ми бачимо у системі може існувати 2 види користувачів:
* Незареєстрований користувач, який може тільки зареєструватись;
* Зареєстрований користувач, він може авторизуватись, продивитись пісні, увімкнути режим навчання, налаштувати за допомогою еквалайзеру звук, та підключитись до IOT приладу;
   
1.2 Опис функцій веб-додатку для користувача
   
   1.2.1 Авторизація та реєстрація
     При переході на сайт користувач бачить перелік усіх гітар на сайті(див. рис. 1.4), він може відкрити їх, продивитись більш детальну інформацію. Або він може перейти до вікна авторизації(див. рис. 1.5) на якій може авторизуватись якщо він вже зареєструвався. У іншому випадку він може перейти до сторінки реєстрації(див. рис. 1.6), на якій може зареєструватись якщо він новий користувач.
     Основний сценарій:
1. Користувач заходить до сайту та реєструється якщо він вперше користується нею;
2. Користувач переходить до вікна авторизації та вводить свої данні вже зареєстрованого акаунту;
3. Користувач потрапляє до на головну сторінку


     Рисунок 1.4 – Вигляд головної сторінки сайту
     
     
 
Рисунок 1.5 – Зовнішний вигляд сторінки авторизації



Рисунок 1.6 – Зовнішний вигляд сторінки реєстрації

1.2.2 Перегляд гітар
	Після авторизації або реєстрації користувача перекидує обратно на головну сторінку, але тепер замість кнопки увійти, кнопка вийти(див. рис. 1.7), тепер він може перейти на сторінку гітар(див. рис. 1.8), передивитись їх, та за бажанням додати до кошику. При додаванні кнопка змінить зовнішний вигляд(див .рис. 1.9).
     Основний сценарій:
1. Користувачу передивляється загальний список гітар;
2. Переходить до сторінки конкретної гітари;
3. Додає до кошику за бажанням;


Рисунок 1.7 – Сторінка авторизованного користувача


Рисунок 1.8 – Сторінка з інформацією про гітару


Рисунок 1.9 – Доданий до корзини товар

1.2.3 Кошик та оформлення замовлення
	Після того як користувач обрав необхідний товар, він може перейти на сторінку кошика, передивитись усі додані товари(див. рис. 1.10), також він може видалити з відти товар, або оформити замовлення, тоді з’явиться сповіщення про успішне оформлення замовлення та загальна вартість покупки(див. рис. 1.11).
     Основний сценарій:
1. Користувачу переходить до сторінки кошику;
2. Передивляється додані товари;
3. За необхідності видаляє їх;
4. Та оформлює замовлення.


Рисунок 1.10 – Кошик товарів

Рисунок 1.11 – Замовлення товарів




1.3 Опис функцій IOT пристрою для користувача

1.3.1 Функція регулювання гучності
    При отриманні пристрою, користувач може його увімкнути, протестувати, та змінити гучність звучання за допомогою потенціометру який вбудовано у систему(див. рис. 1.12 – 1.13).
     Основний сценарій:
1. Користувач вмикає пристрій;
2. Тестує його;
3. За необхідністю змінює гучність.

 
Рисунок 1.12 – Схема IOT пристрою

1.3.2 Вибір режиму звуку
	Пристрій також підтримує можливість використання режимів звуку, які дозволяють отримату звучання для конкретного жанру(див. рис. 1.13).
     Основний сценарій:
1. Користувач обирає жанр музики;
2. Обирає режим для цієї музики;
3. Застосовує його до пристрою.


Рисунок 1.12 – Перший режим

Рисунок 1.13 – Другий режим

1.4 Функції мобільного застосунку для користувача.

1.4.1 Реєстрація та авторизація
     При використанні мобільного застосунку, спочатку необхідно авторизуватись або зареєструватись(див. рис. 1.14) без цього не буде можливості користуватись додатку. Як для авторизації є своя сторінка(див. рис. 1.15) так і для реєстрації(див. рис. 1.16).
     Основний сценарій:
1. Користувач заходить до додатку;
2. Реєструється якщо немає акаунту;
3. Авторизується якщо він є.


Рисунок 1.14 – Вікно реєстрації та авторизації


Рисунок 1.15 – Вікно авторизації

Рисунок 1.16 – Вікно реєстрації

1.4.2 Функція еквалайзеру
     Після авторизації користувач потрапляє до головної сторінки додатку(див. рис. 1.17). Тут він може увімкнути еквалайзер для налаштування звуку(див. рис. 1.18), або обрання з готових режимів(див. рис. 1.19). Налаштування проводиться на декількох частотах.
     Основний сценарій:
1. Користувач вмикає еквалайзер;
2. Налаштовує звук сам або обирає з готових;
3. Зберігає зміни.

Рисунок 1.17 – Головний екран застосунку


Рисунок 1.18 – Вікно налаштування еквалайзеру


Рисунок 1.19 – Заготовлені режими

1.4.3 Режим навчання
     На головному екрані можна побачити список пісень, користувач може відкрити пісню та подивитись її ноти(див. рис. 1.20), та може увімкнути режим навчання, який увімкне IOT пристрій та буде програвати цю пісню з паузами щоб самому зіграти цей елемент.
     Основний сценарій:
1. Користувач обирає пісню;
2. Дивиться ноти;
3. За бажанням вмикає режим навчання.
     

Рисунок 1.20 – Сторінка з нотами пісні
1.4.4	Функція підключення до IOT пристрою
     Після того як був налаштовано звук, необхідно підключитись до пристрою щоб надати йому інформацію про налаштування звуку, або режиму. Для цього на головному екрані є кнопка яка підключає девайс та передає данні(див. рис. 1.21 – 1.22)
     Основний сценарій:
1. Користувач налаштував звук;
2. Підключив девайс до мобільного пристрою;


Рисунок 1.21 – Данні передані до пристрою


Рисунок 1.22 – Успішне підключення до пристрою
2 ПРОЕКТУВАННЯ ПРОГРАМИ
2.1 Архітектура серверної частини

   Серверна система реалізована за допомогою мови програмування JavaScript, з використанням Node JS та фреймворку Express. На ньому знаходиться частина бізнес логіки.
   База даних була створена за допомогою СУБД PostgreSQL(див. рис. 2.1). Її використання було обумовлено великою спільнотою, завдяки якій вона є дуже підтримуваною та розвиненою. Також вона підтримує стандарти SQL, що дозволяє використовувати або переносити данні с інших СУБД, підтримає ACID-властивості, що надає надійність транзакцій, підтримка SSL, що забезпечує безпеку передачі інформації між сервером та клієнтом, та можливість підтримувати гігантські об’єми даних, що дозволяє легко її масштабувати.
   Серверна частина відповідає за частину бізнес логікі, яка відповідна за додавання нових користувачів, додавання вакансій або резюме, та підтвердження або відмова на вакансії або резюме. Також вона має REST API інтерфейс, за допомогою якого інші частини системи можуть взаємодіяти з додатком. Сервер побудований за принципом чистої архітектури(див. рис. 2.2)[1], сутність якої полягає у розподіленні на рівні абстракції, для цього я використовую MVC[5] архітектуру, у якій існує модель бази даних, та контролери які відповідають за свою частину бізнес логіки, та не пересікаються з іншими. Такий підхід дозволяє використовувати принцип SOLID, а саме Single Responsibility Principle, який стверджує що кожна частина програми повинна бути відповідальною за певну бізнес логіку, та змінюватись тільки для зміни цієї бізнес логіки. Сервер взаємодіє з базою даних за допомогою бібліотеки Sequelize, яка дозволяє як відправляти прями запити, так і використовувати ORM для взаємодії.
   Частиною бізнес логіки є наявність реєстрації та авторизації. Для  безпеки користувачів, було додано хешування паролю за допомогою бібліотеки Byscript також використовується JWT токен(див. рис. 2.3), для доступу інформації про користувачів. 
   Головною функцією сайту буде оформлення замовлення, для цього користувачам необхідно буде зареєструватись.
   Також існує можливість отримати знижку при покупці декількох товарів. Розмір знижки залежить від суми замовлення, при 1000 знижка буде складати 5 відсотків, при 2000 буде 10, та при 3000 буде 15. (див. дод. А).
   

Рисунок 2.1 – Структура бази даних

   
   Рисунок 2.2 – Чиста архітектура побудована за допомогою MVC
   

Рисунок 2.3 – Хешування паролів

     Роздивимось як саме працює чиста архітектура у моєму сервері. Принцип цієї архітектурі в розгалуженні та ізоляції елементів. У мене це контролери які відповідають тільки за функціонал, модель яка відповідає тільки за взаємодію з базою даних, шляхи які відповідають за пов’язання серверу з клієнтською частиною застосунку. Роздивимось на прикладі користувачів, є контролер користувачів який відповідає за увесь функціонал з ними, роздивимось авторизацію(див. рис. 2.4), він отримує данні, відправляє їх до моделей(див.рис.2.5), які в свою чергу перевіряють ці данні у базі даних, після чого повертають отриману інформацію назад. Доступ до авторизації надається за шляхом який проложений окремо для кожної функції(див. рис. 2.6). Такий підхід використовується і у інших частинах додатку, він допомагає ізолювати окремі компоненти та зручніше змінювати їх.
     

Рисунок 2.4 – Метод для авторизації користувача


Рисунок 2.5 – Модель для підключення до бази даних


Рисунок 2.6 – Шляхи для користувача

2.2  Архітектура клієнтської частини

     Для розробки клієнтської частини я використав фрейморк React та бібліотеку дизайну Bootstrap.
     Клієнтська частина розроблена за допомогою модульної архітектури(див. рис. 2.7), вона полягає в тому, що система складається з незалежних модулів, кожен з яких відповідає за певну функціональність. Для розробки я використовував методику Component-Based Development, коли програмують компоненти(див. рис. 2.8), які потім можна неодноразово використовувати у сторінках які відображаються. Ця методика гарна тим що дозволяє швидко ремонтувати, та просто розуміти систему. Також завдяки цьому можна використати Liskov Substitution Principle, а саме у вигляди того, що компоненти можуть замінятись без порушення праці додатку.

Рисунок 2.7 – Модульна архітектура клієнту


Рисунок 2.8 – Компоненти

     Роздивимось як працює архітектура серверу моєї системи. Візьмемо головну сторінку. Вона необхідна для виводу гітар, але робить вона це завдяки компонентам(див. рис. 2.9), цей компоненти виводить список гітар(див. рис. 2.10), але він також використовує компонент для отримання одиничних гітар(див. рис. 2.11). А вже цей компонент отримує данні з серверу за допомогою модулю складів, котрі зберігають данні отримані з серверу за допомогою шляхів які були прокладені(див. рис. 2.12 - 2.14).
     

Рисунок 2.9 – Код головної сторінки

Рисунок 2.10 – Код компоненту для виводу списку гітар


Рисунок 2.11 – Код компоненту для отримання однієї гітари

Рисунок 2.12 – Код для отримання даних з серверу


Рисунок 2.13 – Склад для зберігання даних з серверу 


Рисунок 2.14 – Підключення складів 

2.3  Архітектура мобільного додатку

   Для розробки мобільного додатку я використовував андроід студію та мову програмування котлін. 
   Мобільний додаток розроблений за допомогою шарової архітектури(див. рис. 2.15). Вона розбиває додаток на окремі шари, кожен з яких відповідає за певний аспект системи. Це дозволяє ізолювати логіку бізнесу від інтерфейсу користувача, що робить додаток більш структурованим, зручним для підтримки і розширення. Він складається з трьох шарів презентаційного, логіки та доступу до данних.
   Презентаційний Шар
   У моєму проекті цей шар включає наступні компоненти:
   Activity:
* ChordDisplayActivity
* LoginActivity
* MainActivity
* RegisterActivity
   XML-файли макетів (layouts):
* activity_chord_display.xml
* activity_equalize.xml
* activity_login.xml
* activity_main.xml
* activity_register.xml
   Цей шар відповідає за відображення інформації користувачу та обробку його вводу.
   Шар Логіки Застосунку
   Цей шар містить бізнес-логіку вашого додатку. У вашому випадку це можуть бути такі класи:
* Equalize.kt
* RecyclerView.kt
   Ці класи реалізують основну функціональність вашого додатку і обробляють дані, отримані з шару доступу до даних, щоб надати їх презентаційному шару.
   Шар Доступу до Даних
   Цей шар відповідає за взаємодію з зовнішніми джерелами даних. У вашому проекті це:
* ApiService
   ApiService реалізує логіку взаємодії з зовнішніми API для отримання необхідних даних.
     
     

Рисунок 2.15 – Архітектура мобільного додатку
2.4 Архітектура IOT пристрою
     IOT пристрій був створений за допомогою ESP32 та мови програмування C++. Зроблено це було, через вбудовану блютуз систему цього модуля.
     Для емуляції системи було використано онлайн емулятор wokwi. Обрав його через простоту використання та зручний компілятор.
     Схема представляє собою сам модуль. До нього підключено зовнішний динамік для програвання звуку, потенціометр для регулювання гучності, та світлодіоди для відстежування режимів. У емуляторі є два режими музики, це режим року та режим кантрі. Також є режим навчання який запускає гру динаміка з паузами, у які користувач повинен повторити щойно програну музику. Данні потрапляють та пристрій двома шляхами, або через консоль у самому емуляторі, або якщо пристрій зробити фізичним, буде можливість підключатись через блютуз.
     Серед бізнес логіки, присутнє перетворення вхідного аудіо сигналу на сигнал який підтримує динамік.
    Також є функціонал який дозволяє користувачам створювати свій режим музики.
     Кожна пісня яка буде програватись через динамік, буде оброблюватись тим стилем музики який зараз обрано.
     
     
     
     
     
     
     
     
     
     

ВИСНОВКИ


     У процесі курсової роботи на тему «Програмна система навчання грі на гітарі за допомогою розумних пристроїв», я створив систему яка складається з чотирьох частин, а саме серверна частина, клієнтська частина, IOT застосунок та мобільний додаток. В ній користувач може передивитись гітари, додати їх у кошик(див. дод. Б), замовити. Також є можливість керування  IOT пристрою як фізичними приладами, так і за допомогою мобільного застосунку. У ньому також присутні можливості налаштування звуку за допомогою еквалайзеру(див. дод. В), та режим навчання. 
     В результаті розробки було створене повноцінне програмне забезпечення. Для цього я закріпив навички у таких мовах програмування як JavaScript,Kotlin,C++. Фреймворках Node JS, бібліотеках React, Express. Навчився користуватись такими середами розробки як WebStorm, Android Studio.
     У подальшому цю програмну систему можливо розширити та масштабувати, що було реалізовано за допомогою архітектури мого програмного забезпечення, а саме чистої архітектури для серверної частини, модульної архітектури для клієнтської частини та шарової архітектури для мобільного додатку. Ці архітектури дадуть гарну базу для подальшого розвитку проекту та виводу його на світовий ринок.









     ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


     1. Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с.
     2. Flanagan D. JavaScript: The Definitive Guide. 6th ed. — Sebastopol, CA: O'Reilly Media, 2011 — 1096 p. 
     3. Aguilar B. Kotlin for Android Developers: Learn Kotlin the Easy Way While Developing an Android App.
     4. Herron A. Getting MEAN with Mongo, Express, Angular, and Node. 2nd ed. — Greenwich, CT: Manning Publications, 2019 — 550 p.
     5. Документація по патерну MVC. URL: https://metanit.com/sharp/mvc5/1.1.php (дата звернення: 20.04.2024)

















   ДОДАТОК А
   Розрахунок знижки
   
1. function calculateDiscount(totalAmount) {
2.     let discount = 0;
3.     if (totalAmount > 1000) {
4.         discount = 0.05;
5.     }
6.     if (totalAmount > 2000) {
7.         discount = 0.1;
8.     }
9.     if (totalAmount > 3000) {
10.         discount = 0.15;
11.     }
12.     return discount;
13. }
14. 
15. // Функція для розрахунку кінцевої суми з урахуванням знижки
16. function calculateTotalPrice(totalAmount) {
17.     const discount = calculateDiscount(totalAmount);
18.     const discountedAmount = totalAmount * discount;
19.     const totalPrice = totalAmount - discountedAmount;
20.     return totalPrice;
21. }

















ДОДТОК Б
Кошик товарів

1. import React from 'react';
2. import { Container, Row, Col, Card, Button } from "react-bootstrap";
3. import { useCart } from "../context/CartContext";
4. import { createOrder } from "../http/orderAPI";
5. import strings from "../component/localization";
6. 
7. const Cart = () => {
8.     const { cart, removeFromCart, clearCart } = useCart();
9. 
10.     const handleCheckout = async () => {
11.         const UserId = localStorage.getItem("userId");
12.         const OrderDate = new Date().toISOString();
13.         const items = cart.map(item => ({
14.             GuitarID: item.GuitarID,
15.             Quantity: 1
16.         }));
17. 
18.         try {
19.             const { TotalAmount } = await createOrder(UserId, OrderDate, items); // Отримуємо загальну суму замовлення
20. 
21.             clearCart();
22.             alert(`Замовлення успішне. Загальна сума: ${TotalAmount} грн`);
23.         } catch (error) {
24.             console.error("Error creating order:", error);
25.         }
26.     };
27. 
28.     return (
29.         <Container>
30.             <Row>
31.                 <Col>
32.                     <h1>{strings.cart}</h1>
33.                     {cart.map((item) => (
34.                         <Card key={item.GuitarID} style={{ marginBottom: "10px" }}>
35.                             <Card.Body>
36.                                 <Card.Title>{item.Name}</Card.Title>
37.                                 <Card.Subtitle className="mb-2 text-muted">{item.Brand}</Card.Subtitle>
38.                                 <Card.Text>{strings.price}: {item.Price}</Card.Text>
39.                                 <Button variant="danger" onClick={() => removeFromCart(item.GuitarID)}>Видалити</Button>
40.                             </Card.Body>
41.                         </Card>
42.                     ))}
43.                     <Button variant="success" onClick={handleCheckout} disabled={cart.length === 0}>
44.                         Оформити
45.                     </Button>
46.                 </Col>
47.             </Row>
48.         </Container>
49.     );
50. };
51. 
52. export default Cart;
53.







	




















   ДОДАТОК В
   Компонент Equalize.kt
1. package com.example.apz_pzpi_21_10_krashanytsia_yevhen_task5.component
2. import android.content.Intent
3. import android.media.MediaPlayer
4. import android.os.Bundle
5. import android.view.View
6. import android.widget.AdapterView
7. import android.widget.ArrayAdapter
8. import android.widget.ListView
9. import android.widget.Toast
10. import androidx.appcompat.app.AppCompatActivity
11. import com.example.apz_pzpi_21_10_krashanytsia_yevhen_task5.R
12. import com.xeinebiu.audioeffects.AudioEffectManager
13. import com.xeinebiu.audioeffects.AudioEffectViewHelper
14. import org.json.JSONArray
15. import java.io.InputStream
16. 
17. class Equalize : AppCompatActivity() {
18.     private lateinit var audioEffectManager: AudioEffectManager
19.     private lateinit var audioEffectViewHelper: AudioEffectViewHelper
20.     private lateinit var mediaPlayer: MediaPlayer
21.     private var audioSessionId = 0
22.     private lateinit var songListView: ListView
23.     private var songs: MutableList<Song> = mutableListOf()
24. 
25.     override fun onCreate(savedInstanceState: Bundle?) {
26.         super.onCreate(savedInstanceState)
27.         setContentView(R.layout.activity_equalize)
28. 
29.         songListView = findViewById(R.id.song_list)
30.         loadSongsFromJson()
31.         setupListView()
32. 
33.         audioSessionId = setupMediaPlayer()
34.         audioEffectManager = AudioEffectManager(audioSessionId)
35.         audioEffectViewHelper = AudioEffectViewHelper(
36.             this,
37.             supportFragmentManager,
38.             audioEffectManager
39.         )
40.     }
41. 
42.     private fun setupMediaPlayer(): Int {
43.         mediaPlayer = MediaPlayer.create(this, R.raw.pirate_tavern)
44.         mediaPlayer.start()
45.         mediaPlayer.setVolume(.1F, .1F)
46.         return mediaPlayer.audioSessionId
47.     }
48. 
49.     override fun onDestroy() {
50.         super.onDestroy()
51.         mediaPlayer.stop()
52.         mediaPlayer.release()
53.         audioEffectManager.release()
54.     }
55. 
56.     fun asDialog(view: View) {
57.         audioEffectViewHelper.showAsDialog()
58.     }
59. 
60.     fun show(view: View) {
61.         val equalizer = audioEffectManager.equalizer
62.         val bandLevelRange = equalizer.bandLevelRange
63.         val stringBuilder = StringBuilder()
64. 
65.         for (band in 0 until equalizer.numberOfBands) {
66.             val frequency = equalizer.getCenterFreq(band.toShort())
67.             val level = equalizer.getBandLevel(band.toShort())
68. 
69.             stringBuilder.append("Frequency: $frequency Hz, Level: $level dB\n")
70.         }
71. 
72.         // Відображення інформації про частоти і рівні звукових смуг
73.         Toast.makeText(this, stringBuilder.toString(), Toast.LENGTH_LONG).show()
74. 
75.         // Отримання даних, які хочете відправити на пристрій IoT через Bluetooth
76.         val dataToSend = "Some data to send to IoT device"
77. 
78.         // Емуляція підключення до IoT-пристрою по Bluetooth
79.         connectToIoTDevice(dataToSend)
80. 
81.         // Відображення повідомлення користувачу про підключення до пристрою та відправлення даних
82.         Toast.makeText(this, "Connected to IoT device and sent data: $dataToSend", Toast.LENGTH_SHORT).show()
83.     }
84. 
85.     private fun loadSongsFromJson() {
86.         val inputStream: InputStream = resources.openRawResource(R.raw.songs)
87.         val jsonString = inputStream.bufferedReader().use { it.readText() }
88.         val jsonArray = JSONArray(jsonString)
89. 
90.         for (i in 0 until jsonArray.length()) {
91.             val jsonObject = jsonArray.getJSONObject(i)
92.             val name = jsonObject.getString("name")
93.             val chordsJsonArray = jsonObject.getJSONArray("chords")
94.             val chords = mutableListOf<String>()
95. 
96.             for (j in 0 until chordsJsonArray.length()) {
97.                 chords.add(chordsJsonArray.getString(j))
98.             }
99. 
100.             val song = Song(name, chords)
101.             songs.add(song)
102.         }
103.     }
104. 
105.     private fun setupListView() {
106.         val songNames = songs.map { it.name }
107.         val adapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, songNames)
108.         songListView.adapter = adapter
109. 
110.         songListView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ ->
111.             val selectedSong = songs[position]
112.             val intent = Intent(this, ChordDisplayActivity::class.java).apply {
113.                 putExtra("chords", ArrayList(selectedSong.chords))
114.             }
115.             startActivity(intent)
116.         }
117.     }
118. 
119.     private fun connectToIoTDevice(dataToSend: String) {
120. 
121.     }
122. }
123. 
124. data class Song(val name: String, val chords: List<String>)



2


